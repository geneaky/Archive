*N+1문제 정리*

***

1. 다대일 양방향 연관관계에서 즉시 로딩인경우   
jpql은 sql로 번역이 되는데 다대일관계에서 일쪽의 엔티티를 조회한 후 영속성컨텍스트가    
조회한 엔티티의 멤버에서 즉시로딩인 다쪽의 엔티티를 다시 조회하면서 추가로 쿼리가 발생하는 것   
>그렇게 때문에 지연로딩으로 설정해야된다.

2. 다대일 양방향 연관관계에서 지연 로딩인경우     
그러면 1번의 문제를 엔티티를 지연로딩으로 설정하면 막을 수 있을까? 아니요 
바로 다쪽의 엔티티를 조회하지는 않지만 쿼리 결과에 다쪽 엔티티를 포함하여 보내야하기 때문에     
프록시 상태인 다쪽의 엔티티를 사용하는 시점에 영속성 컨텍스트에서 또 쿼리가 발생한다.

3. 다대일 양방향 연관관계에서 fetch join사용
엔티티를 조회할 때 연관된 엔티티를 함께 조회하도록 fetch join을 사용하면 된다. 
하지만fetch join을 걸면 쿼리 결과 로우수가 증가하는 문제가 발생한다.
@XToOne관계는 해당 문제가 없음.
jpql에 fetch join을 넣어주지 않고 @EntityGraph를 사용해서 fetchjoin이 가능하다하지만 이것도 쿼리 결과 로우수가 증가하는 것은 마찬가지
실제로 조회결과는 @XToMany 한개가 fetch join인 경우 distinct를 사용하면 row수를 일치시킬 수 있지    
실제로 조회하는 총 데이터의 수는 변하지 않고 해당 데이터를 메모리에 올린 후 root entity에 대해 distinct 처리가 되는 것    
>> 그렇기 때문에 페이징이 불가능함    
@XToMany관계에서 fetch join으로 페이징하는 경우 결국 연관된 엔티티를 조인하여 전부 메모리에 올린 후 메모리에서 페이징 처리하기 한다.     
> 그래서 이방식은 옳지 않음   
> 최대한 다대일 방향으로 @XToOne관계로 fetch join하는 것이 간편함

4. 다대일 양방향 연관관계에서 default_batch_fetch_size
엔티티를 조회할때 @XToOne관계의 엔티티만 fetch join으로 한번에 조회 후 컬렉션은 in절로 함께 조회되도록 한다.    
