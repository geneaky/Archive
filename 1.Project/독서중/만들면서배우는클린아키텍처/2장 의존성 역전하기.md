
## 단일 책임 원칙

일반적인 해석
> 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.

실제 의도
> 컴포넌트를 변경하는 이유는 오직 하나 뿐

`책임` == `변경의 이유`


변경할 이유가 한 가지인 경우
-> 어떠한 이유로 소프트웨어를 변경하더라도 컴포넌트에 대해 신경쓸 필요가 없다.
-> 하지만 변경할 이유가 있어서 변경을 시도하더라도 컴포넌트 간 의존성으로 인해 변경이 확장될 수 있다.

## 의존성 역전 원칙

> 코드상의 어떤 의존성이든 그 방향을 바꿀 수 있다.

"양쪽 코드를 모두 제어할 수 있는 경우에만 의존성을 역전시킬 수 있다며, 서드파티 라이브러리를 제어할 수 없으니 의존성 역전이 불가능하다고 주장"
-> 서드파티를 직접적으로 사용하지 않고 interface로 한 번 감싸서 사용하면 양쪽 모두 제어할 수 없더라도 한쪽은 제어할 수 있지 않은가?


예시) 엔티티가 도메인 객체를 표현하기 때문에 도메인 코드가 의존하던 엔티티를 도메인 영역에서 사용하고
실제로 이 엔티티를 CRUD하는 작업은 도메인 리파지터리를 구현하는 구현체를 영속성 계층에서 가지게 되면 의존성 역전이 된다.


## 클린아키텍처

- 설계가 비즈니스 규칙,정책 테스트를 용이하게 한다
- 비즈니스 규칙, 정책은 온갖 기술과 외부 애플리케이션, 인터페이스로부터 독립적일 수 있다

![[Pasted image 20241030221740.png|1000]]

코어에 도메인 엔티티가 있고 주변 유즈케이스에서 이 도메인 엔티티에 접근한다
이 유즈케이스는 단일 책임으로 세분화 되어 있다

> 유즈케이스의 구현체를 구현할때 재사용성과 응집도 상승을 위해 응집된 구현 컴포넌트를 만드는 것도 좋다고 생각한다
> 이러한 컴포넌트가 있다면 넓은 서비스를 구현하기에 더 생산성이 좋을듯 하다

이러한 아키텍처로 만들면 도메인 코드를 자유롭게 모델링할 수 있고, [[DDD]] 를 가장 순수한 형태로 적용할 수 있다고 한다


## 클린아키텍처의 대가?

도메인 코어는 순수성을 보장해야 하므로 엔티티에 대한 모델을 각 계층에서 유지보수해야한다

예시) ORM을 사용할때 도메인 엔티티와 영속성 엔티티는 구분되므로 각 계층에서 각각의 목적에 맞게 엔티티를 만들어야 한다
이로인해 도메인 계층와 영속성 계층이 데이터를 주고 받는 과정에서 엔티티간 변환이 발생한다 
같은 유형의 문제가 다른 계층들 사이에서도 발생한다

> 하지만 이것이 바람직한 상태라고 한다





